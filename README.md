# gonverter

Type-safe code generator for Go struct conversions, inspired by Kubernetes conversion-gen.

## Features

- **Zero Configuration** - Just `runtime.Register[From, To]()`, no YAML or config files
- **Type Safe** - Compile errors guide you to implement missing conversions
- **Automatic Mapping** - Same-name, same-type fields are mapped automatically
- **Nested Struct Support** - Nested structs are converted recursively
- **Pointer/Slice/Map Support** - Handles pointer fields, slices, and maps of structs
- **Bidirectional Conversion** - Generate both directions with `RegisterBidirectional`
- **Custom Logic** - Implement conversion functions only when needed
- **IDE Support** - Generated functions work perfectly with autocomplete
- **Clean Code** - Generated code is readable and maintainable

## Installation

```bash
go install github.com/sivchari/gonverter/cmd/gonverter@latest
```

## Quick Start

### 1. Define your types

```go
// handler/user.go
package handler

type UserRequest struct {
    FullName string
    Email    string
    Age      int
    Address  AddressRequest
}

type AddressRequest struct {
    City    string
    ZipCode string
}

// domain/user.go
package domain

type User struct {
    Name    string  // Note: different field name
    Email   string
    Age     int
    Address Address
}

type Address struct {
    City    string
    ZipCode string
}
```

### 2. Register conversions

```go
//go:build gonverter

//go:generate gonverter .

package converter

import (
    "myapp/domain"
    "myapp/handler"
    "github.com/sivchari/gonverter/runtime"
)

// Register the conversion pair
var _ = runtime.Register[*handler.UserRequest, *domain.User]()
```

### 3. Generate code

```bash
go generate ./converter
```

### 4. Generated code

```go
// Code generated by gonverter. DO NOT EDIT.

package converter

// ConvertUserRequestToUser converts UserRequest to User
func ConvertUserRequestToUser(src *handler.UserRequest, dst *domain.User) {
    if src == nil {
        return
    }

    ConvertUserRequestNameToUserName(src, dst)  // Needs custom implementation
    dst.Email = src.Email  // Automatic mapping
    dst.Age = src.Age      // Automatic mapping
    ConvertAddressRequestToAddress(&src.Address, &dst.Address)  // Nested struct
}

// ConvertAddressRequestToAddress converts AddressRequest to Address
func ConvertAddressRequestToAddress(src *handler.AddressRequest, dst *domain.Address) {
    if src == nil {
        return
    }

    dst.City = src.City
    dst.ZipCode = src.ZipCode
}
```

### 5. Implement custom conversions

Since `FullName` -> `Name` cannot be mapped automatically, implement the conversion function:

```go
// converter/custom.go
package converter

func ConvertUserRequestNameToUserName(src *handler.UserRequest, dst *domain.User) {
    dst.Name = src.FullName  // Your custom logic
}
```

### 6. Use it

```go
req := &handler.UserRequest{
    FullName: "John Doe",
    Email:    "john@example.com",
    Age:      30,
    Address: handler.AddressRequest{
        City:    "Tokyo",
        ZipCode: "100-0001",
    },
}

user := &domain.User{}
converter.ConvertUserRequestToUser(req, user)

fmt.Println(user.Name)           // "John Doe"
fmt.Println(user.Address.City)   // "Tokyo"
```

## How It Works

1. **Automatic Mapping** - Same-name + same-type fields are assigned directly
2. **Nested Structs** - Different struct types with the same field name are converted recursively
3. **Custom Functions** - Different names or types require implementing `Convert<Type><Field>To<Type><Field>`
4. **Compile-Time Safety** - Missing implementations cause build errors

## Conversion Rules

### Same name & type -> Automatic

```go
type A struct { Name string }
type B struct { Name string }

// Generated: dst.Name = src.Name
```

### Different name or type -> Custom function required

```go
type A struct { FullName string }
type B struct { Name string }

// Generated: calls ConvertANameToBName(src, dst)
// You implement: dst.Name = src.FullName
```

### Nested structs -> Recursive conversion

```go
type A struct { Address AddressA }
type B struct { Address AddressB }

var _ = runtime.Register[*A, *B]()

// Generated:
// - ConvertAToB calls ConvertAddressAToAddressB(&src.Address, &dst.Address)
// - ConvertAddressAToAddressB is automatically generated
```

### Bidirectional conversion

Use `RegisterBidirectional` to generate conversion functions in both directions:

```go
//go:build gonverter

package converter

import "github.com/sivchari/gonverter/runtime"

// Generates both ConvertUserAPIToUserDomain and ConvertUserDomainToUserAPI
var _ = runtime.RegisterBidirectional[*UserAPI, *UserDomain]()
```

### Pointer fields

```go
type A struct { Profile *ProfileA }
type B struct { Profile *ProfileB }

// Generated: nil checks and allocation handled automatically
// if src.Profile != nil {
//     dst.Profile = new(ProfileB)
//     ConvertProfileAToProfileB(src.Profile, dst.Profile)
// }
```

### Slice fields

```go
type A struct { Items []ItemA }
type B struct { Items []ItemB }

// Generated: slice iteration with element conversion
// dst.Items = make([]ItemB, len(src.Items))
// for i := range src.Items {
//     ConvertItemAToItemB(&src.Items[i], &dst.Items[i])
// }
```

### Map fields

```go
type A struct { Settings map[string]SettingA }
type B struct { Settings map[string]SettingB }

// Generated: map iteration with value conversion
// dst.Settings = make(map[string]SettingB, len(src.Settings))
// for k, v := range src.Settings {
//     var converted SettingB
//     ConvertSettingAToSettingB(&v, &converted)
//     dst.Settings[k] = converted
// }
```

## Custom Function Naming Convention

```
Convert<SourceType><SourceField>To<TargetType><TargetField>
```

Examples:
- `ConvertUserRequestNameToUserName`
- `ConvertUserRequestBirthYearToUserAge`

## License

MIT

## Contributing

Contributions welcome! Please open an issue or PR.
